+++
date = '2025-10-18'
draft = true
title = 'The Ultimate FPGA Build System'
author = 'David Gussler'
+++

## Introduction

Today I want to talk about the typical project / repository structure that I use for efficiently managing the build tools on each customer project. Every project is unique in its own way, so this structure is intentionally flexible, allowing for project-specific script edits where needed, while still being general enough to work in 99% of cases for my typical workflow. Its been slowly developed and tweaked over the years as I add new tools into the mix and make improvements to fix old shortcomings. This structure has evolved with just about every project, so I'm sure this isn't its final form, but its at a place where it works really well for me and I'm quite happy with it so I figured now was as good of a time as any to share it.

The plan for the next set of blog posts is to first give a general introduction to the project structure along with all of the FPGA build tools used, then follow that up with a new post for each major tool.

## Requirements

First of all I need to list the set of requirement / goals.

- **Focus on VHDL** There are plenty of articles out there going over the differences between VHDL and Verilog so this isn't the place to do that. Most of my work has been concentrated in the US defense industry, where VHDL is the standard. I could easily be swayed into picking up Verilog instead, but this is just one of those cases of swimming with the current and taking the path of least resistance. VHDL is a fine language and it works well for me. The ONE major feature I sorely miss that SystemVerilog has over VHDL is interfaces, so once VHDL 2019 interfaces get better tool support, I'll be a very happy guy. They're supported by the NVC simulator and by newer Vivado releases, so I hope to start experimenting with them soon. Maybe I'll make a branch of sblib-open to start playing around with them. Once GHDL support has been implemented and matured a bit I'll probably start going full-throttle with interfaces, but for now I think it's still a bit too early.
- **Focus on Xilinx Vivado** Until I get an Altera / Lattice / Microsemi project, I'll keep the scripting focused on Vivado builds. But like I said earlier, this project structure is always evolving, so it wouldn't be too difficult to integrate other synthesis and implementation tools in the future.
- **Support continuous integration** This is critical. Lots of "old-school" FPGA developers I know don't do this. CI is a classic example of short term pain for long term gain, especially when a project is to be managed with more of a flexible sprint approach than a waterfall approach. Without CI, you'll spend too much time manually managing different build versions, questioning yourself if "v1.1_hardware_tested_1_final.bit" or "v1.1_hardware_tested_real_final.bit" was the right bitstream to release, and being afraid to touch an existing design because "its already been hardware validated". Without CI, small changes to existing designs can become really painful. CI helps you trust your code and gives you confidence while incrementally updating designs.
- **Support single command builds** For example - all it takes to go from source to compiled release is running `make all` from the project root.
- **Support single command simulations** Using something like `make sim`.
- **Only check in source code - No generated or compiled files** No 30 GB zip file project archives with zillions of different pre-compiled bitstreams and unnecessary tool-generated files. You might be surprised by how common "the zip file method" is amongst old-school developers.
- **Vivado projects are built with a script** Do not check-in the `project.xpr`. Using a script makes managing a large project so much more pleasant over the long run.
- **Support Linux and Windows** The build system must be OS-agnostic. I enjoy using Linux, but not everybody does, so I'd never want to force a (present or future) colleague to install a VM. Although - Petalinux / Yocto is a different story, since this requires Linux. But for now, lets just stay focused on the FPGA repository. I almost always keep the software / OS component of an SoC project in its own repo, independent of the FPGA portion. The only case where I might keep them in the same repository would be if the OS was extremely trivial and guaranteed to be versioned and released at the same cadence as the hardware design, but this is almost never the case. You almost always want the flexibility to version track the OS and applications independently from the FPGA. Alright that was a bit of a tangent, but still useful.
- **Support for multiple hardware platforms** Just abut every project I take on is targeted for >1 hardware platform. Usually there is a prototyping stage where I prove out a design using development boards before moving to a custom board. It is also common to have a few different board variants that necessitate tweaked top-level FPGA design variants with different IO, but similar core capabilities. The project structure needs to accommodate that. A long time ago I used to maintain a separate git branch for each hardware platform, but that got messy fast. I'm much happier keeping a single "mainline" development branch with all the different top-level instantiations and constraints in their own platform directory.
- **Support "documentation as code"** What I mean by this is that the project documentation should be stored in the same repository as the code, and should be built, released, and versioned the same way as the code. This makes keeping track of which version of the documentation lines up to which version of the code so much easier than maintaining a separate confluence page or word doc that is *always* out of date with the true state of the code.
- **Should support, but never require Vivado GUI mode** People love to bash on using the Vivado GUI, and I agree with the criticism - having a full CLI workflow is of paramount importance to me for the long-term success of a project. However, there are still cases, in my option, where the vivado GUI really shines, so the idea is to take what's good about the GUI and support it, while also never really needing it if you don't want to use it. It can be really helpful to visualize dangerous CDC paths using the Vivado CDC tool, view elaborated designs to make sure Vivado is interpreting your RTL as you expect, and trace signals thru a visual netlist to check critical paths that are troubling your timing reports.
- **Should support Vivado project mode rather than non-project mode** There are people who swear by non-project mode, and I'm sure it works great for them, but just about every "non-hardcore" FPGA developer I've met expects project mode, and may not even know what non-project mode is. So I think a good middle ground is to use project mode and script the project creation. This makes things more accessible, lets developers enjoy the benefits of project mode, while also keeping everything fully scrutable.
- **Code style should be automatically checked as part of CI** While working on a team, code reviews help developers learn from each other while also keeping everyone accountable. If you know someone else is going to be scrutinizing your code, you'll probably be more likely to produce something of higher quality.Code style is one of those things that should be taken care of before the manual review even happens because style rules can be strictly defend in such a way that they should be automatically checkable by a tool. This gives developers more room during a code review to look for *real* logical issues rather than being distracted by simple style problems.
- **Control / status registers should be generated by a tool** Control and status registers are the main interface between the FPGA and the software that controls the FPGA. one of the most boring, time-consuming, and error-prone processes in FPGA development used to be manually maintaining HDL control / status registers, documentation, and software for those registers. Since the HDL, documentation, and the software interface are essentially just different representations of the exact same register information, this is one of those cases where it makes sense to use code generation.

## The Tools

I've picked up lots of great, mainly open-source, build tools over the years to satisfy the requirements outlined above. I'll list them out here, but I won't go into details yet. I'll dedicate a future post to each tool and update the links in this post once those future articles have been written.

## The Structure

Now that I've outlined all of the major goals of the project structure and listed the tools I use within that structure, I'll now walk through a typical project outline. As a reference, I've created the [fpga_template]() repo, so feel free to clone that to follow along and tweak it for your own purposes. Or even send an email to `david@shrikebyte.com` if you want to talk about the template with me.
