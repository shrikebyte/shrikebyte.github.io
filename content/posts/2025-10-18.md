+++
date = '2025-10-18'
draft = true
title = 'The Ultimate FPGA Project Build System'
author = 'David Gussler'
+++

## Introduction

Today I want to talk about the typical project / repository structure that I use for efficiently managing the build tools on each customer project. Every project is unique in its own way, so this structure is intentionally flexible, allowing for project-specific script edits where needed, while still being general enough to work in 99% of cases for my typical workflow. Its been slowly developed and tweaked over the years as I add new tools into the mix and make improvements to fix old shortcomings. This structure has evolved with just about every project, so I'm sure this isn't its final form, but its at a place where it works really well for me and I'm quite happy with it so I figured now was as good of a time as any to share it.

The plan for the next set of blog posts is to first give a general introduction to the project structure along with all of the FPGA build tools used, then follow that up with a new post for each major tool.

## Requirements

First of all I need to list the set of requirement / goals.

- **Focus on VHDL** There are plenty of articles out there going over the differences between VHDL and Verilog so this isn't the place to do that. Most of my work has been concentrated in the US defense industry, where VHDL is the standard. I could easily be swayed into picking up Verilog instead, but this is just one of those cases of swimming with the current and taking the path of least resistance. VHDL is a fine language and it works well for me. The ONE major feature I sorely miss that SystemVerilog has over VHDL is interfaces, so once VHDL 2019 interfaces get better tool support, I'll be a very happy guy. They're supported by the NVC simulator and by newer Vivado releases, so I hope to start experimenting with them soon. Maybe I'll make a branch of sblib-open to start playing around with them. Once GHDL support has been implemented and matured a bit I'll probably start going full-throttle with interfaces, but for now I think it's still a bit too early.
- **Focus on Xilinx Vivado** Until I get an Altera / Lattice / Microsemi project, I'll keep the scripting focused on Vivado builds. But like I said earlier, this project structure is always evolving, so it wouldn't be too difficult to integrate other synthesis and implementation tools in the future.
- **Support continuous integration** This is critical. Lots of "old-school" FPGA developers I know don't do this. CI is a classic example of short term pain for long term gain, especially when a project is to be managed with more of a flexible sprint approach than a waterfall approach. Without CI, you'll spend too much time manually managing different build versions, questioning yourself if "v1.1_hardware_tested_1_final.bit" or "v1.1_hardware_tested_real_final.bit" was the right bitstream to release, and being afraid to touch an existing design because "its already been hardware validated". Without CI, small changes to existing designs can become really painful. CI helps you trust your code and gives you confidence while incrementally updating designs.
- **Support single command builds** For example - all it takes to go from source to compiled release is running `make all` from the project root.
- **Only check in source code - No generated or compiled files** No 30 GB zip file project archives with zillions of different pre-compiled bitstreams and unnecessary tool-generated files. You might be surprised by how common "the zip file method" is amongst old-school developers.
- **Vivado projects are built with a script** Do not check-in the `project.xpr`. Using a script makes managing a large project so much more pleasant over the long run.
- **Support Linux and Windows** The build system must be OS-agnostic. I enjoy using Linux, but not everybody does, so I'd never want to force a (present or future) colleague to install a VM. Although - Petalinux / Yocto is a different story, since this requires Linux. But for now, lets just stay focused on the FPGA repository. I almost always keep the software / OS component of an SoC project in its own repo, independent of the FPGA portion. The only case where I might keep them in the same repository would be if the OS was extremely trivial and guaranteed to be versioned and released at the same cadence as the hardware design, but this is almost never the case. You almost always want the flexibility to version track the OS and applications independently from the FPGA.
- **Support for multiple hardware platforms** Just abut every project I take on is targeted for >1 hardware platform. Usually there is a prototyping stage where I prove out a design using development boards before moving to a custom circuit board. It is also common to have a few different board variants that necessitate tweaked top-level FPGA design variants with different IO, but similar core capabilities. The project structure needs to accommodate that. A long time ago I used to maintain a separate git branch for each hardware platform, but that got messy fast. I'm much happier just keeping a single "mainline" development branch.
- **Support "documentation as code"** What I mean by this is that the project documentation should be stored in the same repository as the code, and should be built, released, and versioned the same way as the code. This makes keeping track of which version of the documentation lines up to which version of the code so much easier than maintaining a separate confluence page or word doc that is *always* out of date with the true state of the code.
- 