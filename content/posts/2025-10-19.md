+++
date = '2025-10-19'
draft = false
title = 'The Ultimate FPGA Project Structure and Build System'
author = 'David Gussler'
+++

## Introduction

Today I want to talk about the typical project / repository structure that I use for efficiently managing the build tools on customer projects. Every project is a bit unique in its own way, so this structure is intentionally flexible, allowing for project-specific script edits where needed, while still being general enough to work in 99% of cases for my usual workflow. Its been slowly developed and tweaked over the years as I add new tools into the mix and make improvements to fix old shortcomings. This structure has evolved with just about every project, so I'm sure this isn't its final form, but its at a place where I'm happy enough with it to share it.

## Goals

First, I'll list out the goals that motivated this structure, set of tools, and build system.

- **Focus on VHDL** There are plenty of articles out there that go over the differences between VHDL and Verilog so this isn't the place to do that. Most of my work has been concentrated in the US defense industry, where VHDL is the standard. I could easily be swayed into picking up Verilog instead, but this is just one of those cases of swimming with the current and taking the path of least resistance. VHDL is a fine language and it works well for me. The ONE major feature I sorely miss that SystemVerilog has over VHDL is interfaces, so once VHDL 2019 interfaces get better tool support, I'll be a very happy guy. They're supported by the [NVC simulator](https://github.com/nickg/nvc) and by newer Vivado releases, so I hope to start experimenting with them soon. Maybe I'll make a branch of [sblib-open](https://github.com/shrikebyte/sblib-open) to start playing around with them. Once [GHDL](https://github.com/ghdl/ghdl) support has been implemented and matured a bit I'll probably start going full-throttle with interfaces, but for now I think it's still a bit too early.
- **Focus on Xilinx Vivado** Until I get an Altera / Lattice / Microsemi project, I'll keep the scripting focused on Vivado builds. But like I said earlier, this project structure is always evolving, so it wouldn't be too difficult to integrate other synthesis and implementation scripts in the future.
- **Support continuous integration** This is critical. CI is a classic example of short term pain for long term gain, especially when a project is to be managed with more of a flexible sprint approach than a waterfall approach. Without CI, you'll spend too much time manually managing different build versions, questioning yourself if "v1.1_hardware_tested_1_final.bit" or "v1.1_hardware_tested_real_final.bit" was the right bitstream to release, and being afraid to touch an existing design because "its already been hardware validated". Without CI, small changes to existing designs can become really painful. CI helps you trust your code and gives you confidence while incrementally updating designs.
- **Support single command builds** For example - all it takes to go from source to compiled release is running `make all` from the project root.
- **Support single command simulations** Using something like `make sim`.
- **Only check in source code - No generated or compiled files** No 30 GB zip file project archives with zillions of different pre-compiled bitstreams and unnecessary tool-generated files. You might be surprised by how common "the zip file method" is amongst old-school developers.
- **Vivado projects are built with a script** Do not check-in the `project.xpr`. Using a script makes managing a large project so much more pleasant over the long run.
- **Support Linux and Windows** The build system must be OS-agnostic. I enjoy using Linux, but not everybody does, so I'd never want to force a (present or future) colleague to install a VM. Although - Petalinux / Yocto is a different story, since this requires Linux. But for now, lets just stay focused on the FPGA repository. I almost always keep the software / OS component of an SoC project in its own repo, independent of the FPGA portion. The only case where I might keep them in the same repository would be if the OS was extremely trivial and guaranteed to be versioned and released at the same cadence as the hardware design, but this is almost never the case. You almost always want the flexibility to version track the OS and applications independently from the FPGA. Alright that was a bit of a tangent, but still useful.
- **Support for multiple hardware platforms** Just abut every project I take on is targeted for >1 hardware platform. Usually there is a prototyping stage where I prove out a concept using development boards before moving to a custom board. It is also common to have a few different board variants that necessitate creating several tweaked top-level FPGA designs with different IO, but similar core capabilities. The project structure needs to accommodate that. A long time ago I used to maintain a separate git branch for each hardware platform, but that got messy fast. I'm much happier keeping a single "mainline" development branch with all the different top-level instantiations and constraints in their own platform directory.
- **Support "documentation as code"** What I mean by this is that the project documentation should be stored in the same repository as the code, and should be built, released, and versioned the same way as the code. This makes keeping track of which version of the documentation lines up to which version of the code so much easier than maintaining a separate confluence page or word doc that is *always* out of date with the true state of the code.
- **Should support, but never require Vivado GUI mode** People love to bash on using the Vivado GUI, and I agree with the criticism - having a full CLI workflow is of paramount importance to me for the long-term success of a project. However, there are still cases, in my opinion, where the vivado GUI really shines, so the idea is to take what's good about the GUI and support it, while also never needing it if you don't want to use it. It can be really helpful to visualize dangerous CDC paths using the Vivado CDC tool, view elaborated designs to make sure Vivado is interpreting your RTL as you expect, and trace signals thru a visual netlist to check critical paths that are troubling your timing reports.
- **Should support Vivado project mode rather than non-project mode** There are people who swear by non-project mode, and I'm sure it works great for them, but just about every "non-hardcore" FPGA developer I've met expects project mode, and may not even know what non-project mode is. So I think a good middle ground is to use project mode and script the project creation. This makes things more accessible, lets developers enjoy the benefits of project mode, while also keeping everything fully scriptable.
- **Code style should be automatically checked as part of CI** While working on a team, code reviews help developers learn from each other while also keeping everyone accountable. If you know someone else is going to be scrutinizing your code, you'll probably be more likely to produce something of higher quality.Code style is one of those things that should be taken care of before the manual review even happens because style rules can be strictly defend in such a way that they should be automatically checkable by a tool. This gives developers more room during a code review to look for *real* logical issues rather than being distracted by simple style problems.
- **Control / status registers should be generated by a tool** Control and status registers are the main interface between the FPGA and the software that controls the FPGA. one of the most boring, time-consuming, and error-prone processes in FPGA development used to be manually maintaining HDL control / status registers, documentation, and software for those registers. Since the HDL, documentation, and the software interface are essentially just different representations of the exact same register information, this is one of those cases where it makes sense to use code generation.
- **There should be a clear boundary between source files and built files** I've never liked working with projects that generate files all over the place because this can make it difficult to determine what needs to be checked in to source control and what can be safely deleted between builds.
- **Semantic versioning should be used with respect the the software register interface** This helps software developers that depend on your FPGA design understand how changes between FPGA versions will affect their software.

## The Tools

I've picked up lots of great, mainly open-source, build tools over the years to satisfy some the goals outlined above.

- **[VHDL Style Guide](https://vhdl-style-guide.readthedocs.io/en/latest/)** For automated code style checking
- **[VUnit](https://vunit.github.io/)** For simulator abstraction, simulation scripting, and a high-quality verification library
- **[HDL Registers](https://hdl-registers.com/index.html)** For VHDL register generation
- **[GHDL](https://ghdl.github.io/ghdl/about.html)** For VHDL simulation
- **[vhdl_ls](https://github.com/VHDL-LS/rust_hdl)** For a VHDL language server
- **[Vivado](https://www.amd.com/en/products/software/adaptive-socs-and-fpgas/vivado.html)** For synthesis and implementation
- **[Github Actions](https://github.com/features/actions)** For CI scripting.

## The Structure

Now that I've outlined all of the major goals of the project structure and listed the tools I use within that structure, I'll walk through the project directories. As a reference, I've created the [template_fpga](https://github.com/shrikebyte/template_fpga) repo, so feel free to clone that to follow along and tweak it for your own purposes. Or even send an email to `david@shrikebyte.com` if you want to talk about the template with me.

Here is the output of `tree -L 3` from `template_fpga` root directory after cloning the project and running `make all`

```
├── build
│   ├── regs_out
│   │   ├── adder
│   │   ├── gpio
│   │   └── stdver
│   ├── sim_report.xml
│   ├── template_fpga_v0.1.0-basys3
│   │   ├── template_fpga_v0.1.0-basys3.bit
│   │   ├── template_fpga_v0.1.0-basys3_build_info.rpt
│   │   ├── template_fpga_v0.1.0-basys3_cdc.rpt
│   │   ├── template_fpga_v0.1.0-basys3_clock_interaction.rpt
│   │   ├── template_fpga_v0.1.0-basys3_impl.log
│   │   ├── template_fpga_v0.1.0-basys3_io.rpt
│   │   ├── template_fpga_v0.1.0-basys3_methodology.rpt
│   │   ├── template_fpga_v0.1.0-basys3.mmi
│   │   ├── template_fpga_v0.1.0-basys3_power.rpt
│   │   ├── template_fpga_v0.1.0-basys3_synth.log
│   │   ├── template_fpga_v0.1.0-basys3_timing.rpt
│   │   ├── template_fpga_v0.1.0-basys3_util.rpt
│   │   └── template_fpga_v0.1.0-basys3.xsa
│   ├── template_fpga_v0.1.0-basys3.tar.gz
│   ├── template_fpga_v0.1.0-genesys-zu5ev
│   │   ├── template_fpga_v0.1.0-genesys-zu5ev.bit
│   │   ├── template_fpga_v0.1.0-genesys-zu5ev_build_info.rpt
│   │   ├── template_fpga_v0.1.0-genesys-zu5ev_cdc.rpt
│   │   ├── template_fpga_v0.1.0-genesys-zu5ev_clock_interaction.rpt
│   │   ├── template_fpga_v0.1.0-genesys-zu5ev_impl.log
│   │   ├── template_fpga_v0.1.0-genesys-zu5ev_io.rpt
│   │   ├── template_fpga_v0.1.0-genesys-zu5ev_methodology.rpt
│   │   ├── template_fpga_v0.1.0-genesys-zu5ev_power.rpt
│   │   ├── template_fpga_v0.1.0-genesys-zu5ev_synth.log
│   │   ├── template_fpga_v0.1.0-genesys-zu5ev_timing.rpt
│   │   ├── template_fpga_v0.1.0-genesys-zu5ev_util.rpt
│   │   └── template_fpga_v0.1.0-genesys-zu5ev.xsa
│   ├── template_fpga_v0.1.0-genesys-zu5ev.tar.gz
│   └── vivado_out
│       ├── template_fpga_basys3
│       └── template_fpga_genesys-zu5ev
├── CHANGELOG.md
├── doc
│   ├── diagrams.drawio
│   ├── requirements.md
│   └── user_guide.md
├── .gitignore
├── lib
│   └── sblib-open
│       ├── CHANGELOG.md
│       ├── doc
│       ├── LICENSE
│       ├── Makefile
│       ├── README.md
│       ├── src
│       ├── test
│       ├── tools
│       └── vhdl_ls.toml
├── Makefile
├── platforms
│   ├── basys3
│   │   ├── cnstr
│   │   ├── hdl
│   │   ├── ip
│   │   └── platform.mk
│   └── genesys-zu5ev
│       ├── cnstr
│       ├── hdl
│       ├── ip
│       └── platform.mk
├── README.md
├── src
│   └── adder
│       ├── hdl
│       └── regs
├── test
│   └── adder
│       └── adder_tb.vhd
├── tools
│   ├── build.tcl
│   ├── proj.tcl
│   ├── regs.py
│   ├── sim.py
│   └── vsg_rules.yaml
└── vhdl_ls.toml
```

Lets start at the top and work our way down:

- `build` This is the only generated directory, meaning that cleaning up the build artifacts is as simple as running `rm -r build`.
  - `regs_out` holds all of the generated register interface code.
  - `sim_report.xml` is an easily parsable report with the last simulation run results.
  - `template_fpga_v0.1.0-basys3` holds the build artifacts from the synthesis / implementation run. The general form of this directory name is `<repo_name>_<version>-<platform>`. As you can see, this template project supports two different hardware platforms the [Basys3 Artix-7 board](https://digilent.com/shop/basys-3-amd-artix-7-fpga-trainer-board-recommended-for-introductory-users/) and the [Genesys ZU-5EV Zynq MPSoC board](https://digilent.com/shop/genesys-zu-zynq-ultrascale-mpsoc-development-board/). Along with the FPGA programming files, these build directories also store build reports that provide information on pins, utilization, timing, and CDC. Storing these reports helps you track the changes in the design over time and can also help you make utilization estimates for future projects without having to fire up Vivado and rebuild old projects for comparison.
  - `template_fpga_v0.1.0-basys3.tar.gz` This is just a compressed and archived file of the directory we talked about in the last bullet. This is the file that gets stored in your build archives. In my case, I use a Github release for each new version, but there are plenty of other suitable ways of handling this. The one way that is NOT suitable is to store these built releases in your git repo. Git was never meant to store large binary blobs so you'll notice your repos becoming more an more sluggish as new releases are added. Someone might make a case for git LFS here, but I've never tried it before (I've never had a reason to - Github releases already worked well for me and seem to be a natural fit for the problem of long-term build artifact storage).
  - `vivado_out` Here's where the vivado project generation script creates the vivado projects for each platform.
- `CHANGELOG.md` Use this to keep track of changes to the project as it evolves. See [Keep A Changelog](https://keepachangelog.com/en/1.1.0/)
- `doc` Project documentation including diagrams, images, schematic PDFs, user guides, and anything else that may be needed.
- `.gitignore` Lists the files that shouldn't checked in to the repository.
- `lib` External source-code libraries that are not expected to significantly change during the life of the project. These could either be copy-pasted in, or linked as [git submodules](https://www.atlassian.com/git/tutorials/git-submodule) or [git subtrees](https://www.atlassian.com/git/tutorials/git-subtree). I'm fond of using git subtrees for libraries because they are simpler to handle than submodules, while still being easy to update, if needed, without having to manually copy and paste anything. Almost all of my customer projects rely on [sblib-open](https://github.com/shrikebyte/sblib-open) as an external dependency and I typically link it as a git subtree.
- `Makefile` This has all the major build commands for each project. The usual ones are:
  - `make all` to fully build all platforms from a freshly checked out repo.
  - `make sim` to run the self-checking simulations
  - `make style-fix` to reformat the entire hdl codebase to conform to the expected style guidelines.
- `platforms` Has the platform-specific source and configuration files.
- `README.md` Should have general info on the project, including explicitly listing tool dependencies and build instructions.
- `src` Has source files that are common among all the platforms. Each major module should have its own subdirectory in src. Then each module subdirectory is further divided using the following directories:
  - `cnstr` for constraints
  - `hdl` for vhdl and or verilog source code
  - `ip` for tcl scripts to regenerate IPs and or IP-Integrator block designs. NEVER use an ip.xpr file to store an IP, and ALWAYS use a tcl script to regenerate it. Block design scrips can be created from the Vivado TCL commandline using `write_bd_tcl` and IP scripts can be created using `write_ip_tcl`.
  - `regs` for register definition files that are passed to the register generator tool.
- `test` keeps the VUnit testbenches for each project submodule.
- `tools` holds project scripts for the build tools.
- `vhdl_ls.toml` lists the vhdl source files that should be included for analysis by the language server.

## Conclusion

Today we've taken a look at the project structure and tools that I like to use as part of my FPGA development and maintenance process. In it, I tried to adopt modern software standards for continuous improvement while also making full use of awesome freely available open-source FPGA automation tools.
