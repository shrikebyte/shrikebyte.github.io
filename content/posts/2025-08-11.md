+++
date = '2025-08-11'
draft = false
title = 'So What the Heck is an FPGA?'
author = 'David Gussler'
+++

## What's an FPGA?

An FPGA is a reconfigurable digital logic IC (Integrated Circuit) often used for highly parallelized computing and custom interfaces to bespoke hardware. You'll usually find them in specialized, lower-volume systems where high throughput or low latency is critical - applications like datacenter, networking, RADAR, aerospace & defense, medical devices, 5G / wireless communications, scientific research, AI accelerators, imaging, and test / measurement instrumentation.

## What are they good at?

FPGAs hit a sweet spot by delivering performance that pure software can't match, without the up-front cost of an ASIC, all while retaining most of the system flexibility offered by software. FPGAs also offer some unique security features that make them attractive to specific markets.

## What are they not so good at?

Power - They use a lot of it, at least when to compared to their ASIC counterparts. It is absolutely possible to develop low-power FPGA systems, but they'll never be as power-efficient as an ASIC.

Logic Density - Due to the reconfigurable nature, a significant portion of the chip is just dedicated to routing resources, which increases the die size relative to the logic equations implemented.

Clock Speed - If designed well, a modern FPGA functional unit can hit around 600 MHz. That pales in comparison to ASICs, which can hit upwards of 5 GHz now.

## What's an SoC?

Today, many FPGA-centric systems significantly benefit by pairing the FPGA with a traditional processor (running either bare metal software, an OS like Linux, or both at the same time!) to handle higher-level tasks while the FPGA handles lower-level tasks. Devices called SoCs (System on a Chip) combine an FPGA with a traditional processor and peripherals on one chip, allowing for tightly coupled and highly optimized interactions between hardware and software. As we approach the end of [Moore's Law](https://en.wikipedia.org/wiki/Moore%27s_law) this form of [heterogeneous computing](https://en.wikipedia.org/wiki/Heterogeneous_computing) is becoming more and more important.

## Who makes these things?

* **AMD - [formerly Xilinx](https://www.reddit.com/r/FPGA/comments/sshjhv/amd_completes_acquisition_of_xilinx/)** Is a leader in the business, with over 50% marketshare as of 2025. They focus on the mid to high end market and are generally considered to have the best design tools.
* **Altera [formerly Intel, formerly Altera](https://www.reddit.com/r/FPGA/comments/1jz6vyn/intel_sells_altera_to_private_equity_firm_for_875b/)** comes in at second behind Xilinx.
* **Lattice** Focuses on the lower-end of the market, targeting lower-cost lower-power applications.
* **Microchip** has some of the best [radiation hardened](https://en.wikipedia.org/wiki/Radiation_hardening) devices on the market, making them a great choice for space-based applications.
* Chinese and Russian knockoffs. These companies make clones of chips from the previously listed brands, sometimes the chips are even fully compatible with the name-brand development tools. I would avoid these.

## How do you program them?

First, you write [HDL](https://en.wikipedia.org/wiki/Hardware_description_language) using a language like SystemVerilog or VHDL. Then you should simulate these design files to prove that they work. Next you write a set of constraints to define signal timing relationships and set which chip pins are used for IO signals. Finally you'd use the the chip vendor's programming toolchain to "compile" these sources into a binary file that is used to program the device.

Those are the basics, but this process gets more complicated when you introduce code generation, [high level synthesis](https://en.wikipedia.org/wiki/High-level_synthesis), vendor IPs, [soft processors](https://en.wikipedia.org/wiki/Soft_microprocessor), [embedded Linux](https://en.wikipedia.org/wiki/Linux_on_embedded_systems), and others. All of these tools help improve programmer efficiency (at least in theory), but like any engineering problem, their benefits have to be weighed against the increased complexity they bring.

Shrikebyte has an [opensource HDL library](https://github.com/shrikebyte/sblib-open) that we are consistently improving. This library is a set of common reuseable components that helps us design more efficiently. In future blog posts, we'll go over our important library components, development process, tools, and common scripts used to make designing FPGAs faster and more fun.

## Where does Shrikebyte come in?

Having an expert in your corner who knows how to tailor a well-balanced system is the best way to harness the power of these highly capable SoC devices.

But with great power comes great... complexity. FPGAs are notorious for wrecking project timelines, whether that be caused by toolchain bugs, vague requirements, miscommunications, or outright [unexplainable witchcraft](https://news.ycombinator.com/item?id=39751509#:~:text=Unconventional%20Uses%20of%20FPGAs%20%7C%20Hacker%20News&text=%3E%20A%20ring%20oscillator%20in%20an,the%20ring%20oscillator%20will%20shift.), leading to a dark downward spiral into the depths of [FPGA Hell](https://zipcpu.com/fpga-hell.html).

Shrikebyte knows how to navigate these pitfalls and keep your project on track. We're hyper-fixated on solving tough problems in the "messy middle" by aligning hardware and software from the start. We have a practical worldview that helps us predict and grapple with your problems head on.

[Contact us](/contact/) to get started.
