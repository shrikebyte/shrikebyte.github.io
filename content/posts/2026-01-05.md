+++
date = '2026-01-05'
draft = true
title = 'VHDL 19 Interfaces'
author = 'David Gussler'
+++

## Introduction

Its 2026 and VHDL Interfaces, a new feature added in the 2019 language standard, are finally ready for prime-time! The two barriers previously preventing their use were synthesis tool support and open-source simulator support. After spending a couple months working on a set of general-purpose axi-stream modules using interfaces, I can confidently say that both Vivado (synthesis / implementation) and NVC (simulation) have great interface support. VHDL interfaces are ready for new designs in 2026!

## Motivation

I'll point to some existing articles that explain interfaces and why you'd want them. I'll also give my own quick take on them.

[Here's an explanation from Sigasi](https://www.sigasi.com/tech/what-is-new-in-vhdl-2019-part2/)

[Here's one from OSVVM](https://osvvm.org/archives/1668)

[And finally, a short description from the Vivado documentation](https://docs.amd.com/r/en-US/ug901-vivado-synthesis/Interfaces?tocId=QKHQ7u5ExGtLMcrbbVy23w)

One of the biggest annoyances with HDL design is connecting up large interfaces between modules while coding a large system. AXI is one of the best examples of this. Who wants to repeatedly and manually connect up 100 independent signals between modules? This is error prone, time-wasting, and the sort of problem that seems easily fixable, if only we had better tools.

Enter VHDL interfaces.

For a long time, engineers solved this problem by using a two-record approach. One record to group common input signals, and another to group output signals. This worked pretty well, but VHDL 19 introduced an even better way to handle this, by adding a built-in way to group input and output signals with interface views. This means that connecting up a long chain of axi stream modules is as easy as using one signal for the input and one for the output. If you've ever used Vivado's IP integrator, you could think of VHDL interfaces as an actually useable, text-based, version of that.

## Usage

First, create a package with the common interface definition. For maximum flexibility, I'd recommend using unconstrained arrays and allowing the user of the module to specify vector sizes at the instantiation. Here's an example of an axi stream interface definition.

```VHDL
--##############################################################################
--# File : axis_pkg.vhd
--# Auth : David Gussler
--# Lang : VHDL'19
--# ============================================================================
--# AXI-Stream type definitions.
--##############################################################################

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

package axis_pkg is

  -- AXI-Stream type
  type axis_t is record
    tready : std_ulogic;
    tvalid : std_ulogic;
    tlast  : std_ulogic;
    tdata  : std_ulogic_vector;
    tkeep  : std_ulogic_vector;
    tuser  : std_ulogic_vector;
  end record;

  -- AXI-Stream array
  type axis_arr_t is array(natural range <>) of axis_t;

  -- Manager view
	view m_axis_v of axis_t is
    tready : in;
    tvalid : out;
    tlast  : out;
    tdata  : out;
    tkeep  : out;
    tuser  : out;
  end view;

  -- Subordinate view
  alias s_axis_v is m_axis_v'converse;

  -- Monitor view
  view monitor_axis_v of axis_t is
    tready : in;
    tvalid : in;
    tlast  : in;
    tdata  : in;
    tkeep  : in;
    tuser  : in;
  end view;

end package;
```

Next, create an entity / architecture that use the new interface. Below, I show an axi stream broadcaster because tt's a short, standalone example using an interface at the input port and an array of interfaces at the output port.

```VHDL
--##############################################################################
--# File : axis_broadcast.vhd
--# Auth : David Gussler
--# Lang : VHDL'19
--# ============================================================================
--# Broadcasts one input stream to several output streams.
--##############################################################################

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use work.axis_pkg.all;

entity axis_broadcast is
  port (
    clk  : in    std_ulogic;
    srst : in    std_ulogic;
    --
    s_axis : view s_axis_v;
    --
    m_axis : view (m_axis_v) of axis_arr_t
  );
end entity;

architecture rtl of axis_broadcast is

  signal int_axis_tready : std_ulogic_vector(m_axis'range);
  signal int_axis_tvalid : std_ulogic_vector(m_axis'range);
  signal int_axis_tdata  : std_ulogic_vector(s_axis.tdata'range);
  signal int_axis_tuser  : std_ulogic_vector(s_axis.tuser'range);
  signal int_axis_tkeep  : std_ulogic_vector(s_axis.tkeep'range);
  signal int_axis_tlast  : std_ulogic;

begin

  s_axis.tready <= (and int_axis_tready) or not (or int_axis_tvalid);

  prc_broadcast : process (clk) is begin
    if rising_edge(clk) then

      for i in m_axis'range loop
        if int_axis_tready(i) then
          int_axis_tvalid(i) <= '0';
        end if;
      end loop;

      if s_axis.tvalid and s_axis.tready then
        int_axis_tvalid <= (others=> '1');
        int_axis_tlast  <= s_axis.tlast;
        int_axis_tdata  <= s_axis.tdata;
        int_axis_tkeep  <= s_axis.tkeep;
        int_axis_tuser  <= s_axis.tuser;
      end if;

      if srst then
        int_axis_tvalid <= (others=> '0');
      end if;
    end if;
  end process;

  gen_assign_outputs : for i in m_axis'range generate
    int_axis_tready(i) <= m_axis(i).tready;
    m_axis(i).tvalid   <= int_axis_tvalid(i);
    m_axis(i).tlast    <= int_axis_tlast;
    m_axis(i).tdata    <= int_axis_tdata;
    m_axis(i).tkeep    <= int_axis_tkeep;
    m_axis(i).tuser    <= int_axis_tuser;
  end generate;

end architecture;

```

Finally, instantiate the new entity in the top-level design. Here I only show a snippet of the top level with the relevant lines of code.

```VHDL
architecture rtl of top is

  constant NUM_OUTPUTS : integer := 3;

  constant DW : integer := 16;
  constant KW : integer := 2;
  constant UW : integer := 4;

  signal clk  : std_ulogic;
  signal srst : std_ulogic;

  signal s_axis : axis_t (
    tdata(DW - 1 downto 0),
    tkeep(KW - 1 downto 0),
    tuser(UW - 1 downto 0)
  );

  signal m_axis : axis_arr_t(0 to NUM_OUTPUTS - 1)(
    tdata(DW - 1 downto 0),
    tkeep(KW - 1 downto 0),
    tuser(UW - 1 downto 0)
  );

begin

  u_axis_broadcast : entity work.axis_broadcast
  port map (
    clk    => clk,
    srst   => srst,
    s_axis => s_axis,
    m_axis => m_axis
  );

end architecture;
```

## Sblib AXI Stream Modules

If you want more examples of axi stream modules built with VHDL interfaces, I have a whole library of them in the [Shrikebyte open source VHDL repo](https://github.com/shrikebyte/sblib), complete with fully self-checking VUnit testbenches and Github Actions CI. To my knowledge, there aren't any other existing open source general-purpose VHDL libraries that make use of interfaces.

So far, the list of modules includes:

- `axis_arb.vhd`
  - Priority arbiter.
- `axis_broadcast.vhd`
  - Broadcast on source stream to several destinations.
- `axis_cat.vhd`
  - Packet concatenate. Useful for adding a header or trailer to a payload.
- `axis_demux.vhd`
  - De-multiplexer.
- `axis_fifo_async.vhd`
  - Async FIFO with optional packet mode.
- `axis_fifo.vhd`
  - Sync FIFO with optional packet mode.
- `axis_mux.vhd`
  - Multiplexer.
- `axis_pack.vhd`
  - Tkeep packer - Removes null bytes from an axi stream and re-packs it to guarantee that all tkeep bits are high on all beats, except for tlast.
- `axis_pipes.vhd`
  - Cascaded version of axis_pipe, for use when multiple back-to-back pipeline stages are needed.
- `axis_pipe.vhd`
  - Single pipeline stage to break combinatorial paths. AKA skid buffer.
- `axis_pkg.vhd`
  - Package containing the common axi stream interface definition.
- `axis_resize.vhd`
  - Upsize or downsize the width of a stream. Drops null tkeep bytes wherever it can to improve protocol efficiency.
- `axis_slice.vhd`
  - Packet slice. Slices one packet into two at a user-specified byte boundary. Useful for stripping a header or trailer from a payload.

Why would I make this when so many other open source and vendor libraries already exist?

1. As an FPGA programmer, I like having complete control over the low-level implementation details of my designs. Primarily because having a deep understanding each LUT and flip-flop makes debugging a breeze. I'm sure many other types of programmers would appreciate being able to write their own libraries as well, but almost always, the level of productivity that they have to operate at fully prevents them from doing this. While writing your own glibc would be completely out of the question in 99% of cases, FPGA programmers are in a different position, where it is actually feasible to write their own personal low-level library of FPGA design elements within a reasonable time period since the level of abstraction is so low. If I wanted to spend all of my time gluing together existing libraries, I'd become a Javascript programmer. I love the low-level stuff.
2. I wanted to start using VHDL interfaces, and I knew of no existing libraries that already use them.
3. Relying on vendor IP locks you into a vendor. It's a good short-term stop-gap solution, but I typically try to limit vendor IP to high-speed transceiver interfaces and hard macro blocks, like the Zynq IP or PCIe DMA engine, for example.
4. I'm starting work on an open source FPGA-based [DVB-S2](https://en.wikipedia.org/wiki/DVB-S2) transceiver for wireless video transport, and I'll need these generic AXI stream blocks for this project.
5. Its fun!

## Comparison to SystemVerilog

The main difference between VHDL interfaces compared to SystemVerilog interfaces, is that SV lets you specify constants inside of interface definitions, whereas VHDL does not.

Here's an example from the excellent [taxi repo](https://github.com/fpganinja/taxi/) of open source SV components:

```SystemVerilog
// SPDX-License-Identifier: MIT
/*

Copyright (c) 2025 FPGA Ninja, LLC

Authors:
- Alex Forencich

*/

interface taxi_axis_if #(
    // Width of AXI stream interfaces in bits
    parameter DATA_W = 8,
    // tkeep signal width (bytes per cycle)
    parameter KEEP_W = ((DATA_W+7)/8),
    // Use tkeep signal
    parameter logic KEEP_EN = KEEP_W > 1,
    // Use tstrb signal
    parameter logic STRB_EN = 1'b0,
    // Use tlast signal
    parameter logic LAST_EN = 1'b1,
    // Use tid signal
    parameter logic ID_EN = 0,
    // tid signal width
    parameter ID_W = 8,
    // Use tdest signal
    parameter logic DEST_EN = 0,
    // tdest signal width
    parameter DEST_W = 8,
    // Use tuser signal
    parameter logic USER_EN = 0,
    // tuser signal width
    parameter USER_W = 1
)
();
    logic [DATA_W-1:0] tdata;
    logic [KEEP_W-1:0] tkeep;
    logic [KEEP_W-1:0] tstrb;
    logic [ID_W-1:0] tid;
    logic [DEST_W-1:0] tdest;
    logic [USER_W-1:0] tuser;
    logic tlast;
    logic tvalid;
    logic tready;

    modport src (
        output tdata,
        output tkeep,
        output tstrb,
        output tid,
        output tdest,
        output tuser,
        output tlast,
        output tvalid,
        input  tready
    );

    modport snk (
        input  tdata,
        input  tkeep,
        input  tstrb,
        input  tid,
        input  tdest,
        input  tuser,
        input  tlast,
        input  tvalid,
        output tready
    );

    modport mon (
        input  tdata,
        input  tkeep,
        input  tstrb,
        input  tid,
        input  tdest,
        input  tuser,
        input  tlast,
        input  tvalid,
        input  tready
    );

endinterface
```

Notice that the vector widths and usage of optional signals like tkeep and tuser are specified at the interface definition. I haven't missed this feature. The vector lengths are not a problem because I keep them unconstrained, so the user can sill specify those while defining the signals. Enabling or disabling optional signals is a bit more problematic. The best solution, in my opinion, is to document the module so that the user can tie unused input signals to default values leave unused output signals disconnected, letting synthesis optimize away the unused signals. I prefer this solution because it reduces the number of generics required which reduces the verification complexity.

## Issues

I ran into a few problems while trying out the new language feature, but they were all quickly resolved. I tend to disagree with this advice "Stay away from any new language features. Only use VHDL'93 for maximum tool compatibility!". I'm of the belief that the language should work for you, not the other way around. I'm more than willing to put up with occasional tool-bugs here and there if it means that I can have a worthwhile productivity gain and if it makes the coding process more fun. I don't expect to ever need to run my new designs through ISE, and if I do need to for some unexpected reason, I'll deal with it at that time. I'd rather code for the 99% of use cases. I will not sacrifice progress for the 1% of cases that I likely won't ever need.

1. NVC 1
2. NVC 2
3. Vivado 1
4. Vivado 2

## Conclusion
